import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";
import _intlMessageformat from "intl-messageformat";
import { useIsSSR } from "@react-aria/ssr";
import _react, { useEffect, useState, useContext, useCallback, useRef } from "react";

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// https://en.wikipedia.org/wiki/Right-to-left
const $d26e725ad56fbcb2c25f52b7de27$var$RTL_SCRIPTS = new Set(['Arab', 'Syrc', 'Samr', 'Mand', 'Thaa', 'Mend', 'Nkoo', 'Adlm', 'Rohg', 'Hebr']);
const $d26e725ad56fbcb2c25f52b7de27$var$RTL_LANGS = new Set(['ae', 'ar', 'arc', 'bcc', 'bqi', 'ckb', 'dv', 'fa', 'glk', 'he', 'ku', 'mzn', 'nqo', 'pnb', 'ps', 'sd', 'ug', 'ur', 'yi']);
/**
 * Determines if a locale is read right to left using [Intl.Locale]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale}.
 */

function $d26e725ad56fbcb2c25f52b7de27$export$isRTL(locale) {
  // If the Intl.Locale API is available, use it to get the script for the locale.
  // This is more accurate than guessing by language, since languages can be written in multiple scripts.
  // @ts-ignore
  if (Intl.Locale) {
    // @ts-ignore
    let script = new Intl.Locale(locale).maximize().script;
    return $d26e725ad56fbcb2c25f52b7de27$var$RTL_SCRIPTS.has(script);
  } // If not, just guess by the language (first part of the locale)


  let lang = locale.split('-')[0];
  return $d26e725ad56fbcb2c25f52b7de27$var$RTL_LANGS.has(lang);
}

function $d26e725ad56fbcb2c25f52b7de27$export$numberFormatSignDisplayPolyfill(numberFormat, signDisplay, num) {
  if (signDisplay === 'auto') {
    return numberFormat.format(num);
  } else if (signDisplay === 'never') {
    return numberFormat.format(Math.abs(num));
  } else {
    let needsPositiveSign = false;

    if (signDisplay === 'always') {
      needsPositiveSign = num > 0 || Object.is(num, 0);
    } else if (signDisplay === 'exceptZero') {
      if (Object.is(num, -0) || Object.is(num, 0)) {
        num = Math.abs(num);
      } else {
        needsPositiveSign = num > 0;
      }
    }

    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num); // ignore RTL/LTR marker character

      let minus = negative.replace(noSign, '').replace(/\u200e|\u061C/, '');

      if ([...minus].length !== 1) {
        console.warn('@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case');
      }

      let positive = negative.replace(noSign, '!!!').replace(minus, '+').replace('!!!', noSign);
      return positive;
    } else {
      return numberFormat.format(num);
    }
  }
}

/**
 * Gets the locale setting of the browser.
 */
function $e851d0b81d46abd5f971c8e95c27f1$export$getDefaultLocale() {
  // @ts-ignore
  let locale = typeof navigator !== 'undefined' && (navigator.language || navigator.userLanguage) || 'en-US';
  return {
    locale,
    direction: $d26e725ad56fbcb2c25f52b7de27$export$isRTL(locale) ? 'rtl' : 'ltr'
  };
}

let $e851d0b81d46abd5f971c8e95c27f1$var$currentLocale = $e851d0b81d46abd5f971c8e95c27f1$export$getDefaultLocale();
let $e851d0b81d46abd5f971c8e95c27f1$var$listeners = new Set();

function $e851d0b81d46abd5f971c8e95c27f1$var$updateLocale() {
  $e851d0b81d46abd5f971c8e95c27f1$var$currentLocale = $e851d0b81d46abd5f971c8e95c27f1$export$getDefaultLocale();

  for (let listener of $e851d0b81d46abd5f971c8e95c27f1$var$listeners) {
    listener($e851d0b81d46abd5f971c8e95c27f1$var$currentLocale);
  }
}
/**
 * Returns the current browser/system language, and updates when it changes.
 */


function $e851d0b81d46abd5f971c8e95c27f1$export$useDefaultLocale() {
  let isSSR = useIsSSR();
  let [defaultLocale, setDefaultLocale] = useState($e851d0b81d46abd5f971c8e95c27f1$var$currentLocale);
  useEffect(() => {
    if ($e851d0b81d46abd5f971c8e95c27f1$var$listeners.size === 0) {
      window.addEventListener('languagechange', $e851d0b81d46abd5f971c8e95c27f1$var$updateLocale);
    }

    $e851d0b81d46abd5f971c8e95c27f1$var$listeners.add(setDefaultLocale);
    return () => {
      $e851d0b81d46abd5f971c8e95c27f1$var$listeners.delete(setDefaultLocale);

      if ($e851d0b81d46abd5f971c8e95c27f1$var$listeners.size === 0) {
        window.removeEventListener('languagechange', $e851d0b81d46abd5f971c8e95c27f1$var$updateLocale);
      }
    };
  }, []); // We cannot determine the browser's language on the server, so default to
  // en-US. This will be updated after hydration on the client to the correct value.

  if (isSSR) {
    return {
      locale: 'en-US',
      direction: 'ltr'
    };
  }

  return defaultLocale;
}

const $cff8541df3b5c83067b2ab3ee0d20$var$I18nContext = _react.createContext(null);

export function I18nProvider(props) {
  let {
    locale,
    children
  } = props;
  let defaultLocale = $e851d0b81d46abd5f971c8e95c27f1$export$useDefaultLocale();
  let value = locale ? {
    locale,
    direction: $d26e725ad56fbcb2c25f52b7de27$export$isRTL(locale) ? 'rtl' : 'ltr'
  } : defaultLocale;
  return /*#__PURE__*/_react.createElement($cff8541df3b5c83067b2ab3ee0d20$var$I18nContext.Provider, {
    value: value
  }, children);
}
/**
 * Returns the current locale and layout direction.
 */

export function useLocale() {
  let defaultLocale = $e851d0b81d46abd5f971c8e95c27f1$export$useDefaultLocale();
  let context = useContext($cff8541df3b5c83067b2ab3ee0d20$var$I18nContext);
  return context || defaultLocale;
}
const $f58d206cee90f9c2bf3c03e4522c35$var$formatterCache = new Map();
/**
 * Handles formatting ICU Message strings to create localized strings for the current locale.
 * Automatically updates when the locale changes, and handles caching of messages for performance.
 * @param strings - A mapping of languages to strings by key.
 */

export function useMessageFormatter(strings) {
  let {
    locale: currentLocale
  } = useLocale(); // Check the cache

  let localeCache = $f58d206cee90f9c2bf3c03e4522c35$var$formatterCache.get(strings);

  if (localeCache && localeCache.has(currentLocale)) {
    return localeCache.get(currentLocale);
  } // Add to the formatter cache if needed


  if (!localeCache) {
    localeCache = new Map();
    $f58d206cee90f9c2bf3c03e4522c35$var$formatterCache.set(strings, localeCache);
  } // Get the strings for the current locale


  let localeStrings = $f58d206cee90f9c2bf3c03e4522c35$var$selectLocale(strings, currentLocale); // Create a new message formatter

  let cache = {};

  let formatMessage = (key, variables) => {
    let message = cache[key + '.' + currentLocale];

    if (!message) {
      let msg = localeStrings[key];

      if (!msg) {
        throw new Error("Could not find intl message " + key + " in " + currentLocale + " locale");
      }

      message = new _intlMessageformat(msg, currentLocale);
      cache[key] = message;
    }

    return message.format(variables);
  };

  localeCache.set(currentLocale, formatMessage);
  return formatMessage;
}

function $f58d206cee90f9c2bf3c03e4522c35$var$selectLocale(strings, locale) {
  // If there is an exact match, use it.
  if (strings[locale]) {
    return strings[locale];
  } // Attempt to find the closest match by language.
  // For example, if the locale is fr-CA (French Canadian), but there is only
  // an fr-FR (France) set of strings, use that.


  let language = $f58d206cee90f9c2bf3c03e4522c35$var$getLanguage(locale);

  for (let key in strings) {
    if (key.startsWith(language + '-')) {
      return strings[key];
    }
  } // Nothing close, use english.


  return strings['en-US'];
}

function $f58d206cee90f9c2bf3c03e4522c35$var$getLanguage(locale) {
  // @ts-ignore
  if (Intl.Locale) {
    // @ts-ignore
    return new Intl.Locale(locale).language;
  }

  return locale.split('-')[0];
}

let $b0007c63a64054c318efb8b6cd0053f$var$formatterCache = new Map();
/**
 * Provides localized date formatting for the current locale. Automatically updates when the locale changes,
 * and handles caching of the date formatter for performance.
 * @param options - Formatting options.
 */

export function useDateFormatter(options) {
  let {
    locale
  } = useLocale();
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');

  if ($b0007c63a64054c318efb8b6cd0053f$var$formatterCache.has(cacheKey)) {
    return $b0007c63a64054c318efb8b6cd0053f$var$formatterCache.get(cacheKey);
  }

  let formatter = new Intl.DateTimeFormat(locale, options);
  $b0007c63a64054c318efb8b6cd0053f$var$formatterCache.set(cacheKey, formatter);
  return formatter;
}

/**
 * Provides localized number parsing for the current locale.
 * Idea from https://observablehq.com/@mbostock/localized-number-parsing.
 */
export function useNumberParser() {
  let {
    locale
  } = useLocale();
  const numberData = useRef({
    group: null,
    decimal: null,
    numeral: null,
    index: null
  });
  useEffect(() => {
    const parts = new Intl.NumberFormat(locale).formatToParts(12345.6);
    const numerals = [...new Intl.NumberFormat(locale, {
      useGrouping: false
    }).format(9876543210)].reverse();
    const index = new Map(numerals.map((d, i) => [d, i]));
    numberData.current.group = new RegExp("[" + parts.find(d => d.type === 'group').value + "]", 'g');
    numberData.current.decimal = new RegExp("[" + parts.find(d => d.type === 'decimal').value + "]");
    numberData.current.numeral = new RegExp("[" + numerals.join('') + "]", 'g');

    numberData.current.index = d => index.get(d);
  }, [locale]);
  const parse = useCallback(value => {
    value = value.trim().replace(numberData.current.group, '').replace(numberData.current.decimal, '.').replace(numberData.current.numeral, numberData.current.index);
    return value ? +value : NaN;
  }, []);
  return {
    parse
  };
}
let $ece3e138e83d330f42860705a2ec18a$var$formatterCache = new Map();
let $ece3e138e83d330f42860705a2ec18a$var$supportsSignDisplay = false;

try {
  // @ts-ignore
  $ece3e138e83d330f42860705a2ec18a$var$supportsSignDisplay = new Intl.NumberFormat('de-DE', {
    signDisplay: 'exceptZero'
  }).resolvedOptions().signDisplay === 'exceptZero'; // eslint-disable-next-line no-empty
} catch (e) {}
/**
 * Provides localized number formatting for the current locale. Automatically updates when the locale changes,
 * and handles caching of the number formatter for performance.
 * @param options - Formatting options.
 */


export function useNumberFormatter(options) {
  let {
    locale
  } = useLocale();
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');

  if ($ece3e138e83d330f42860705a2ec18a$var$formatterCache.has(cacheKey)) {
    return $ece3e138e83d330f42860705a2ec18a$var$formatterCache.get(cacheKey);
  }

  let numberFormatter = new Intl.NumberFormat(locale, options); // @ts-ignore

  let {
    signDisplay
  } = options || {};
  $ece3e138e83d330f42860705a2ec18a$var$formatterCache.set(cacheKey, !$ece3e138e83d330f42860705a2ec18a$var$supportsSignDisplay && signDisplay != null ? new Proxy(numberFormatter, {
    get(target, property) {
      if (property === 'format') {
        return v => $d26e725ad56fbcb2c25f52b7de27$export$numberFormatSignDisplayPolyfill(numberFormatter, signDisplay, v);
      } else {
        return target[property];
      }
    }

  }) : numberFormatter);
  return numberFormatter;
}
let $a4045a18d7252bf6de9312e613c4e$var$cache = new Map();
/**
 * Provides localized string collation for the current locale. Automatically updates when the locale changes,
 * and handles caching of the collator for performance.
 * @param options - Collator options.
 */

export function useCollator(options) {
  let {
    locale
  } = useLocale();
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : '');

  if ($a4045a18d7252bf6de9312e613c4e$var$cache.has(cacheKey)) {
    return $a4045a18d7252bf6de9312e613c4e$var$cache.get(cacheKey);
  }

  let formatter = new Intl.Collator(locale, options);
  $a4045a18d7252bf6de9312e613c4e$var$cache.set(cacheKey, formatter);
  return formatter;
}

/**
 * Provides localized string search functionality that is useful for filtering or matching items
 * in a list. Options can be provided to adjust the sensitivity to case, diacritics, and other parameters.
 */
export function useFilter(options) {
  let collator = useCollator(_babelRuntimeHelpersEsmExtends({
    usage: 'search'
  }, options)); // TODO(later): these methods don't currently support the ignorePunctuation option.

  return {
    startsWith(string, substring) {
      if (substring.length === 0) {
        return true;
      } // Normalize both strings so we can slice safely
      // TODO: take into account the ignorePunctuation option as well...


      string = string.normalize('NFC');
      substring = substring.normalize('NFC');
      return collator.compare(string.slice(0, substring.length), substring) === 0;
    },

    endsWith(string, substring) {
      if (substring.length === 0) {
        return true;
      }

      string = string.normalize('NFC');
      substring = substring.normalize('NFC');
      return collator.compare(string.slice(-substring.length), substring) === 0;
    },

    contains(string, substring) {
      if (substring.length === 0) {
        return true;
      }

      string = string.normalize('NFC');
      substring = substring.normalize('NFC');
      let scan = 0;
      let sliceLen = substring.length;

      for (; scan + sliceLen <= string.length; scan++) {
        let slice = string.slice(scan, scan + sliceLen);

        if (collator.compare(substring, slice) === 0) {
          return true;
        }
      }

      return false;
    }

  };
}
//# sourceMappingURL=module.js.map
