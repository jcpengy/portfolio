import { mergeProps, useLayoutEffect, useResizeObserver } from "@react-aria/utils";
export { useResizeObserver };
import { useLocale } from "@react-aria/i18n";
import _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";
import { useIsSSR } from "@react-aria/ssr";
import _react, { useEffect, useState, useImperativeHandle, useMemo, useRef, useContext, useCallback } from "react";
import _clsx from "clsx";
export let shouldKeepSpectrumClassNames = false;
export function keepSpectrumClassNames() {
  shouldKeepSpectrumClassNames = true;
  console.warn('Legacy spectrum-prefixed class names enabled for backward compatibility. ' + 'We recommend replacing instances of CSS overrides targeting spectrum selectors ' + 'in your app with custom class names of your own, and disabling this flag.');
}
export function classNames(cssModule) {
  let classes = [];

  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }

  for (let value of values) {
    if (typeof value === 'object' && value) {
      let mapped = {};

      for (let key in value) {
        if (cssModule[key]) {
          mapped[cssModule[key]] = value[key];
        }

        if (shouldKeepSpectrumClassNames || !cssModule[key]) {
          mapped[key] = value[key];
        }
      }

      classes.push(mapped);
    } else if (typeof value === 'string') {
      if (cssModule[value]) {
        classes.push(cssModule[value]);
      }

      if (shouldKeepSpectrumClassNames || !cssModule[value]) {
        classes.push(value);
      }
    } else {
      classes.push(value);
    }
  }

  return _clsx(...classes);
}
export function getWrappedElement(children) {
  let element;

  if (typeof children === 'string') {
    element = /*#__PURE__*/_react.createElement("span", null, children);
  } else {
    element = _react.Children.only(children);
  }

  return element;
}
export function useMediaQuery(query) {
  let supportsMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia === 'function';
  let [matches, setMatches] = useState(() => supportsMatchMedia ? window.matchMedia(query).matches : false);
  useEffect(() => {
    if (!supportsMatchMedia) {
      return;
    }

    let mq = window.matchMedia(query);

    let onChange = evt => {
      setMatches(evt.matches);
    };

    mq.addListener(onChange);
    return () => {
      mq.removeListener(onChange);
    };
  }, [supportsMatchMedia, query]); // If in SSR, the media query should never match. Once the page hydrates,
  // this will update and the real value will be returned.

  let isSSR = useIsSSR();
  return isSSR ? false : matches;
}
export function createDOMRef(ref) {
  return {
    UNSAFE_getDOMNode() {
      return ref.current;
    }

  };
}
export function createFocusableRef(domRef, focusableRef) {
  if (focusableRef === void 0) {
    focusableRef = domRef;
  }

  return _babelRuntimeHelpersEsmExtends({}, createDOMRef(domRef), {
    focus() {
      if (focusableRef.current) {
        focusableRef.current.focus();
      }
    }

  });
}
export function useDOMRef(ref) {
  let domRef = useRef(null);
  useImperativeHandle(ref, () => createDOMRef(domRef));
  return domRef;
}
export function useFocusableRef(ref, focusableRef) {
  let domRef = useRef(null);
  useImperativeHandle(ref, () => createFocusableRef(domRef, focusableRef));
  return domRef;
}
export function unwrapDOMRef(ref) {
  return {
    get current() {
      return ref.current && ref.current.UNSAFE_getDOMNode();
    }

  };
}
export function useUnwrapDOMRef(ref) {
  return useMemo(() => unwrapDOMRef(ref), [ref]);
}

const $f838b598b03ac1d3fd85d427f7d189$var$Context = /*#__PURE__*/_react.createContext(null);

$f838b598b03ac1d3fd85d427f7d189$var$Context.displayName = 'BreakpointContext';
export function BreakpointProvider(props) {
  let {
    children,
    matchedBreakpoints
  } = props;
  return /*#__PURE__*/_react.createElement($f838b598b03ac1d3fd85d427f7d189$var$Context.Provider, {
    value: {
      matchedBreakpoints
    }
  }, children);
}
export function useMatchedBreakpoints(breakpoints) {
  let entries = Object.entries(breakpoints).sort((_ref, _ref2) => {
    let [, valueA] = _ref;
    let [, valueB] = _ref2;
    return valueB - valueA;
  });
  let breakpointQueries = entries.map((_ref3) => {
    let [, value] = _ref3;
    return "(min-width: " + value + "px)";
  });
  let supportsMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia === 'function';

  let getBreakpointHandler = () => {
    let matched = [];

    for (let i in breakpointQueries) {
      let query = breakpointQueries[i];

      if (window.matchMedia(query).matches) {
        matched.push(entries[i][0]);
      }
    }

    matched.push('base');
    return matched;
  };

  let [breakpoint, setBreakpoint] = useState(() => supportsMatchMedia ? getBreakpointHandler() : ['base']);
  useEffect(() => {
    if (!supportsMatchMedia) {
      return;
    }

    let onResize = () => {
      setBreakpoint(getBreakpointHandler());
    };

    window.addEventListener('resize', onResize);
    return () => {
      window.removeEventListener('resize', onResize);
    };
  }, [supportsMatchMedia]); // If in SSR, the media query should never match. Once the page hydrates,
  // this will update and the real value will be returned.

  let isSSR = useIsSSR();
  return isSSR ? ['base'] : breakpoint;
}
export function useBreakpoint() {
  return useContext($f838b598b03ac1d3fd85d427f7d189$var$Context);
}
export const baseStyleProps = {
  margin: ['margin', dimensionValue],
  marginStart: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('marginLeft', 'marginRight'), dimensionValue],
  marginEnd: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('marginRight', 'marginLeft'), dimensionValue],
  // marginLeft: ['marginLeft', dimensionValue],
  // marginRight: ['marginRight', dimensionValue],
  marginTop: ['marginTop', dimensionValue],
  marginBottom: ['marginBottom', dimensionValue],
  marginX: [['marginLeft', 'marginRight'], dimensionValue],
  marginY: [['marginTop', 'marginBottom'], dimensionValue],
  width: ['width', dimensionValue],
  height: ['height', dimensionValue],
  minWidth: ['minWidth', dimensionValue],
  minHeight: ['minHeight', dimensionValue],
  maxWidth: ['maxWidth', dimensionValue],
  maxHeight: ['maxHeight', dimensionValue],
  isHidden: ['display', $e8ff0135e78060c4cd2a3148981a7a3$var$hiddenValue],
  alignSelf: ['alignSelf', passthroughStyle],
  justifySelf: ['justifySelf', passthroughStyle],
  position: ['position', $e8ff0135e78060c4cd2a3148981a7a3$var$anyValue],
  zIndex: ['zIndex', $e8ff0135e78060c4cd2a3148981a7a3$var$anyValue],
  top: ['top', dimensionValue],
  bottom: ['bottom', dimensionValue],
  start: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('left', 'right'), dimensionValue],
  end: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('right', 'left'), dimensionValue],
  left: ['left', dimensionValue],
  right: ['right', dimensionValue],
  order: ['order', $e8ff0135e78060c4cd2a3148981a7a3$var$anyValue],
  flex: ['flex', $e8ff0135e78060c4cd2a3148981a7a3$var$flexValue],
  flexGrow: ['flexGrow', passthroughStyle],
  flexShrink: ['flexShrink', passthroughStyle],
  flexBasis: ['flexBasis', passthroughStyle],
  gridArea: ['gridArea', passthroughStyle],
  gridColumn: ['gridColumn', passthroughStyle],
  gridColumnEnd: ['gridColumnEnd', passthroughStyle],
  gridColumnStart: ['gridColumnStart', passthroughStyle],
  gridRow: ['gridRow', passthroughStyle],
  gridRowEnd: ['gridRowEnd', passthroughStyle],
  gridRowStart: ['gridRowStart', passthroughStyle]
};
export const viewStyleProps = _babelRuntimeHelpersEsmExtends({}, baseStyleProps, {
  backgroundColor: ['backgroundColor', $e8ff0135e78060c4cd2a3148981a7a3$var$backgroundColorValue],
  borderWidth: ['borderWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderStartWidth: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderLeftWidth', 'borderRightWidth'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderEndWidth: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderRightWidth', 'borderLeftWidth'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderLeftWidth: ['borderLeftWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderRightWidth: ['borderRightWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderTopWidth: ['borderTopWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderBottomWidth: ['borderBottomWidth', $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderXWidth: [['borderLeftWidth', 'borderRightWidth'], $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderYWidth: [['borderTopWidth', 'borderBottomWidth'], $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue],
  borderColor: ['borderColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderStartColor: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderLeftColor', 'borderRightColor'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderEndColor: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderRightColor', 'borderLeftColor'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderLeftColor: ['borderLeftColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderRightColor: ['borderRightColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderTopColor: ['borderTopColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderBottomColor: ['borderBottomColor', $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderXColor: [['borderLeftColor', 'borderRightColor'], $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderYColor: [['borderTopColor', 'borderBottomColor'], $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue],
  borderRadius: ['borderRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderTopStartRadius: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderTopLeftRadius', 'borderTopRightRadius'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderTopEndRadius: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderTopRightRadius', 'borderTopLeftRadius'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderBottomStartRadius: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderBottomLeftRadius', 'borderBottomRightRadius'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderBottomEndRadius: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('borderBottomRightRadius', 'borderBottomLeftRadius'), $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderTopLeftRadius: ['borderTopLeftRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderTopRightRadius: ['borderTopRightRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderBottomLeftRadius: ['borderBottomLeftRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  borderBottomRightRadius: ['borderBottomRightRadius', $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue],
  padding: ['padding', dimensionValue],
  paddingStart: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('paddingLeft', 'paddingRight'), dimensionValue],
  paddingEnd: [$e8ff0135e78060c4cd2a3148981a7a3$var$rtl('paddingRight', 'paddingLeft'), dimensionValue],
  paddingLeft: ['paddingLeft', dimensionValue],
  paddingRight: ['paddingRight', dimensionValue],
  paddingTop: ['paddingTop', dimensionValue],
  paddingBottom: ['paddingBottom', dimensionValue],
  paddingX: [['paddingLeft', 'paddingRight'], dimensionValue],
  paddingY: [['paddingTop', 'paddingBottom'], dimensionValue],
  overflow: ['overflow', passthroughStyle]
});
const $e8ff0135e78060c4cd2a3148981a7a3$var$borderStyleProps = {
  borderWidth: 'borderStyle',
  borderLeftWidth: 'borderLeftStyle',
  borderRightWidth: 'borderRightStyle',
  borderTopWidth: 'borderTopStyle',
  borderBottomWidth: 'borderBottomStyle'
};

function $e8ff0135e78060c4cd2a3148981a7a3$var$rtl(ltr, rtl) {
  return direction => direction === 'rtl' ? rtl : ltr;
}

const $e8ff0135e78060c4cd2a3148981a7a3$var$UNIT_RE = /(%|px|em|rem|vw|vh|auto|cm|mm|in|pt|pc|ex|ch|rem|vmin|vmax|fr)$/;
const $e8ff0135e78060c4cd2a3148981a7a3$var$FUNC_RE = /^\s*\w+\(/;
const $e8ff0135e78060c4cd2a3148981a7a3$var$SPECTRUM_VARIABLE_RE = /(static-)?size-\d+|single-line-(height|width)/g;
export function dimensionValue(value) {
  if (typeof value === 'number') {
    return value + 'px';
  }

  if ($e8ff0135e78060c4cd2a3148981a7a3$var$UNIT_RE.test(value)) {
    return value;
  }

  if ($e8ff0135e78060c4cd2a3148981a7a3$var$FUNC_RE.test(value)) {
    return value.replace($e8ff0135e78060c4cd2a3148981a7a3$var$SPECTRUM_VARIABLE_RE, 'var(--spectrum-global-dimension-$&, var(--spectrum-alias-$&))');
  }

  return "var(--spectrum-global-dimension-" + value + ", var(--spectrum-alias-" + value + "))";
}
export function responsiveDimensionValue(value, matchedBreakpoints) {
  value = getResponsiveProp(value, matchedBreakpoints);
  return dimensionValue(value);
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$colorValue(value, type) {
  if (type === void 0) {
    type = 'default';
  }

  return "var(--spectrum-global-color-" + value + ", var(--spectrum-semantic-" + value + "-color-" + type + "))";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$backgroundColorValue(value) {
  return "var(--spectrum-alias-background-color-" + value + ", " + $e8ff0135e78060c4cd2a3148981a7a3$var$colorValue(value, 'background') + ")";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$borderColorValue(value) {
  if (value === 'default') {
    return 'var(--spectrum-alias-border-color)';
  }

  return "var(--spectrum-alias-border-color-" + value + ", " + $e8ff0135e78060c4cd2a3148981a7a3$var$colorValue(value, 'border') + ")";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$borderSizeValue(value) {
  return "var(--spectrum-alias-border-size-" + value + ")";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$borderRadiusValue(value) {
  return "var(--spectrum-alias-border-radius-" + value + ")";
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$hiddenValue(value) {
  return value ? 'none' : undefined;
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$anyValue(value) {
  return value;
}

function $e8ff0135e78060c4cd2a3148981a7a3$var$flexValue(value) {
  if (typeof value === 'boolean') {
    return value ? '1' : undefined;
  }

  return '' + value;
}

export function convertStyleProps(props, handlers, direction, matchedBreakpoints) {
  let style = {};

  for (let key in props) {
    let styleProp = handlers[key];

    if (!styleProp || props[key] == null) {
      continue;
    }

    let [name, convert] = styleProp;

    if (typeof name === 'function') {
      name = name(direction);
    }

    let prop = getResponsiveProp(props[key], matchedBreakpoints);
    let value = convert(prop);

    if (Array.isArray(name)) {
      for (let k of name) {
        style[k] = value;
      }
    } else {
      style[name] = value;
    }
  }

  for (let prop in $e8ff0135e78060c4cd2a3148981a7a3$var$borderStyleProps) {
    if (style[prop]) {
      style[$e8ff0135e78060c4cd2a3148981a7a3$var$borderStyleProps[prop]] = 'solid';
      style.boxSizing = 'border-box';
    }
  }

  return style;
}
export function useStyleProps(props, handlers, options) {
  if (handlers === void 0) {
    handlers = baseStyleProps;
  }

  if (options === void 0) {
    options = {};
  }

  let {
    UNSAFE_className,
    UNSAFE_style
  } = props,
      otherProps = _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose(props, ["UNSAFE_className", "UNSAFE_style"]);

  let breakpointProvider = useBreakpoint();
  let {
    direction
  } = useLocale();
  let {
    matchedBreakpoints = (breakpointProvider == null ? void 0 : breakpointProvider.matchedBreakpoints) || ['base']
  } = options;
  let styles = convertStyleProps(props, handlers, direction, matchedBreakpoints);

  let style = _babelRuntimeHelpersEsmExtends({}, UNSAFE_style, styles); // @ts-ignore


  if (otherProps.className) {
    console.warn('The className prop is unsafe and is unsupported in React Spectrum v3. ' + 'Please use style props with Spectrum variables, or UNSAFE_className if you absolutely must do something custom. ' + 'Note that this may break in future versions due to DOM structure changes.');
  } // @ts-ignore


  if (otherProps.style) {
    console.warn('The style prop is unsafe and is unsupported in React Spectrum v3. ' + 'Please use style props with Spectrum variables, or UNSAFE_style if you absolutely must do something custom. ' + 'Note that this may break in future versions due to DOM structure changes.');
  }

  let styleProps = {
    style,
    className: UNSAFE_className
  };

  if (getResponsiveProp(props.isHidden, matchedBreakpoints)) {
    styleProps.hidden = true;
  }

  return {
    styleProps
  };
}
export function passthroughStyle(value) {
  return value;
}
export function getResponsiveProp(prop, matchedBreakpoints) {
  if (prop && typeof prop === 'object' && !Array.isArray(prop)) {
    for (let i = 0; i < matchedBreakpoints.length; i++) {
      let breakpoint = matchedBreakpoints[i];

      if (prop[breakpoint] != null) {
        return prop[breakpoint];
      }
    }

    return prop.base;
  }

  return prop;
}

let $e1c64f5d291c45a968556986464cdba1$var$SlotContext = /*#__PURE__*/_react.createContext(null);

export function useSlotProps(props, defaultSlot) {
  let slot = props.slot || defaultSlot;
  let {
    [slot]: slotProps = {}
  } = useContext($e1c64f5d291c45a968556986464cdba1$var$SlotContext) || {};
  return mergeProps(slotProps, props);
}
export function cssModuleToSlots(cssModule) {
  return Object.keys(cssModule).reduce((acc, slot) => {
    acc[slot] = {
      UNSAFE_className: cssModule[slot]
    };
    return acc;
  }, {});
}
export function SlotProvider(props) {
  let parentSlots = useContext($e1c64f5d291c45a968556986464cdba1$var$SlotContext) || {};
  let {
    slots = {},
    children
  } = props; // Merge props for each slot from parent context and props

  let value = useMemo(() => Object.keys(parentSlots).concat(Object.keys(slots)).reduce((o, p) => _babelRuntimeHelpersEsmExtends({}, o, {
    [p]: mergeProps(parentSlots[p] || {}, slots[p] || {})
  }), {}), [parentSlots, slots]);
  return /*#__PURE__*/_react.createElement($e1c64f5d291c45a968556986464cdba1$var$SlotContext.Provider, {
    value: value
  }, children);
}
export function ClearSlots(props) {
  let {
    children
  } = props,
      otherProps = _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose(props, ["children"]);

  let content = children;

  if (_react.Children.toArray(children).length <= 1) {
    if (typeof children === 'function') {
      // need to know if the node is a string or something else that react can render that doesn't get props
      content = /*#__PURE__*/_react.cloneElement(_react.Children.only(children), otherProps);
    }
  }

  return /*#__PURE__*/_react.createElement($e1c64f5d291c45a968556986464cdba1$var$SlotContext.Provider, {
    value: {}
  }, content);
}
export function useHasChild(query, ref) {
  let [hasChild, setHasChild] = useState(true);
  useLayoutEffect(() => {
    setHasChild(!!(ref.current && ref.current.querySelector(query)));
  }, [setHasChild, query, ref]);
  return hasChild;
}
const $db7f8d67f553ae22a3f659d9cb2a$var$MOBILE_SCREEN_WIDTH = 700;
export function useIsMobileDevice() {
  let isSSR = useIsSSR();

  if (isSSR || typeof window === 'undefined') {
    return false;
  }

  return window.screen.width <= $db7f8d67f553ae22a3f659d9cb2a$var$MOBILE_SCREEN_WIDTH;
}
// This hook works like `useState`, but when setting the value, you pass a generator function
// that can yield multiple values. Each yielded value updates the state and waits for the next
// layout effect, then continues the generator. This allows sequential updates to state to be
// written linearly.
export function useValueEffect(defaultValue) {
  let [value, setValue] = useState(defaultValue);
  let effect = useRef(null); // Store the function in a ref so we can always access the current version
  // which has the proper `value` in scope.

  let nextRef = useRef(null);

  nextRef.current = () => {
    // Run the generator to the next yield.
    let newValue = effect.current.next(); // If the generator is done, reset the effect.

    if (newValue.done) {
      effect.current = null;
      return;
    } // If the value is the same as the current value,
    // then continue to the next yield. Otherwise,
    // set the value in state and wait for the next layout effect.


    if (value === newValue.value) {
      nextRef.current();
    } else {
      setValue(newValue.value);
    }
  };

  useLayoutEffect(() => {
    // If there is an effect currently running, continue to the next yield.
    if (effect.current) {
      nextRef.current();
    }
  });
  let queue = useCallback(fn => {
    effect.current = fn();
    nextRef.current();
  }, [effect, nextRef]);
  return [value, queue];
}
//# sourceMappingURL=module.js.map
