{"mappings":"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","sources":["./packages/@react-stately/numberfield/src/useNumberFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep, useControlledState} from '@react-stately/utils';\nimport {NumberFieldProps} from '@react-types/numberfield';\nimport {NumberFormatter, NumberParser} from '@internationalized/number';\nimport {useCallback, useEffect, useMemo, useRef, useState} from 'react';\n\nexport interface NumberFieldState {\n  /**\n   * The current text value of the input. Updated as the user types,\n   * and formatted according to `formatOptions` on blur.\n   */\n  inputValue: string,\n  /**\n   * The currently parsed number value, or NaN if a valid number could not be parsed.\n   * Updated based on the `inputValue` as the user types.\n   */\n  numberValue: number,\n  /** The minimum value of the number field. */\n  minValue: number,\n  /** The maximum value of the number field. */\n  maxValue: number,\n  /** Whether the current value can be incremented according to the maximum value and step. */\n  canIncrement: boolean,\n  /** Whether the current value can be decremented according to the minimum value and step. */\n  canDecrement: boolean,\n  /**\n   * Validates a user input string according to the current locale and format options.\n   * Values can be partially entered, and may be valid even if they cannot currently be parsed to a number.\n   * Can be used to implement validation as a user types.\n   */\n  validate(value: string): boolean,\n  /** Sets the current text value of the input. */\n  setInputValue(val: string): void,\n  /**\n   * Commits the current input value. The value is parsed to a number, clamped according\n   * to the minimum and maximum values of the field, and snapped to the nearest step value.\n   * This will fire the `onChange` prop with the new value, and if uncontrolled, update the `numberValue`.\n   * Typically this is called when the field is blurred.\n   */\n  commit(): void,\n  /** Increments the current input value to the next step boundary, and fires `onChange`. */\n  increment(): void,\n  /** Decrements the current input value to the next step boundary, and fires `onChange`. */\n  decrement(): void,\n  /** Sets the current value to the `maxValue` if any, and fires `onChange`. */\n  incrementToMax(): void,\n  /** Sets the current value to the `minValue` if any, and fires `onChange`. */\n  decrementToMin(): void\n}\n\ninterface NumberFieldStateProps extends NumberFieldProps {\n  /**\n   * The locale that should be used for parsing.\n   * @default 'en-US'\n   */\n  locale: string\n}\n\n/**\n * Provides state management for a number field component. Number fields allow users to enter a number,\n * and increment or decrement the value using stepper buttons.\n */\nexport function useNumberFieldState(\n  props: NumberFieldStateProps\n): NumberFieldState {\n  let {\n    minValue,\n    maxValue,\n    step,\n    formatOptions,\n    value,\n    defaultValue,\n    onChange,\n    locale,\n    isDisabled,\n    isReadOnly\n  } = props;\n\n  let [numberValue, setNumberValue] = useControlledState<number>(value, isNaN(defaultValue) ? NaN : defaultValue, onChange);\n  let [inputValue, setInputValue] = useState(() => isNaN(numberValue) ? '' : new NumberFormatter(locale, formatOptions).format(numberValue));\n\n  let numberParser = useMemo(() => new NumberParser(locale, formatOptions), [locale, formatOptions]);\n  let numberingSystem = useMemo(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);\n  let formatter = useMemo(() => new NumberFormatter(locale, {...formatOptions, numberingSystem}), [locale, formatOptions, numberingSystem]);\n  let intlOptions = useMemo(() => formatter.resolvedOptions(), [formatter]);\n  let format = useCallback((value: number) => isNaN(value) ? '' : formatter.format(value), [formatter]);\n\n  let clampStep = !isNaN(step) ? step : 1;\n  if (intlOptions.style === 'percent' && isNaN(step)) {\n    clampStep = 0.01;\n  }\n\n  // Update the input value when the number value or format options change. This is done\n  // in a useEffect so that the controlled behavior is correct and we only update the\n  // textfield after prop changes.\n  useEffect(() => {\n    setInputValue(format(numberValue));\n  }, [numberValue, locale, formatOptions]);\n\n  // Store last parsed value in a ref so it can be used by increment/decrement below\n  let parsedValue = useMemo(() => numberParser.parse(inputValue), [numberParser, inputValue]);\n  let parsed = useRef(0);\n  parsed.current = parsedValue;\n\n  let commit = () => {\n    // Set to empty state if input value is empty\n    if (!inputValue.length) {\n      setNumberValue(NaN);\n      setInputValue(value === undefined ? '' : format(numberValue));\n      return;\n    }\n\n    // if it failed to parse, then reset input to formatted version of current number\n    if (isNaN(parsed.current)) {\n      setInputValue(format(numberValue));\n      return;\n    }\n\n    // Clamp to min and max, round to the nearest step, and round to specified number of digits\n    let clampedValue: number;\n    if (isNaN(step)) {\n      clampedValue = clamp(parsed.current, minValue, maxValue);\n    } else {\n      clampedValue = snapValueToStep(parsed.current, minValue, maxValue, step);\n    }\n\n    clampedValue = numberParser.parse(format(clampedValue));\n    setNumberValue(clampedValue);\n\n    // in a controlled state, the numberValue won't change, so we won't go back to our old input without help\n    setInputValue(format(value === undefined ? clampedValue : numberValue));\n  };\n\n  let safeNextStep = (operation: '+' | '-', minMax: number) => {\n    let prev = parsed.current;\n\n    if (isNaN(prev)) {\n      // if the input is empty, start from the min/max value when incrementing/decrementing,\n      // or zero if there is no min/max value defined.\n      let newValue = isNaN(minMax) ? 0 : minMax;\n      return snapValueToStep(newValue, minValue, maxValue, clampStep);\n    } else {\n      // otherwise, first snap the current value to the nearest step. if it moves in the direction\n      // we're going, use that value, otherwise add the step and snap that value.\n      let newValue = snapValueToStep(prev, minValue, maxValue, clampStep);\n      if ((operation === '+' && newValue > prev) || (operation === '-' && newValue < prev)) {\n        return newValue;\n      }\n\n      return snapValueToStep(\n        handleDecimalOperation(operation, prev, clampStep),\n        minValue,\n        maxValue,\n        clampStep\n      );\n    }\n  };\n\n  let increment = () => {\n    setNumberValue((previousValue) => {\n      let newValue = safeNextStep('+', minValue);\n\n      // if we've arrived at the same value that was previously in the state, the\n      // input value should be updated to match\n      // ex type 4, press increment, highlight the number in the input, type 4 again, press increment\n      // you'd be at 5, then incrementing to 5 again, so no re-render would happen and 4 would be left in the input\n      if (newValue === previousValue) {\n        setInputValue(format(newValue));\n      }\n\n      return newValue;\n    });\n  };\n\n  let decrement = () => {\n    setNumberValue((previousValue) => {\n      let newValue = safeNextStep('-', maxValue);\n\n      if (newValue === previousValue) {\n        setInputValue(format(newValue));\n      }\n\n      return newValue;\n    });\n  };\n\n  let incrementToMax = () => {\n    if (maxValue != null) {\n      setNumberValue(snapValueToStep(maxValue, minValue, maxValue, clampStep));\n    }\n  };\n\n  let decrementToMin = () => {\n    if (minValue != null) {\n      setNumberValue(minValue);\n    }\n  };\n\n  let canIncrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(maxValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) > parsedValue ||\n      handleDecimalOperation('+', parsedValue, clampStep) <= maxValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let canDecrement = useMemo(() => (\n    !isDisabled &&\n    !isReadOnly &&\n    (\n      isNaN(parsedValue) ||\n      isNaN(minValue) ||\n      snapValueToStep(parsedValue, minValue, maxValue, clampStep) < parsedValue ||\n      handleDecimalOperation('-', parsedValue, clampStep) >= minValue\n    )\n  ), [isDisabled, isReadOnly, minValue, maxValue, clampStep, parsedValue]);\n\n  let validate = (value: string) => numberParser.isValidPartialNumber(value, minValue, maxValue);\n\n  return {\n    validate,\n    increment,\n    incrementToMax,\n    decrement,\n    decrementToMin,\n    canIncrement,\n    canDecrement,\n    minValue,\n    maxValue,\n    numberValue: parsedValue,\n    setInputValue,\n    inputValue,\n    commit\n  };\n}\n\nfunction handleDecimalOperation(operator: '-' | '+', value1: number, value2: number): number {\n  let result = operator === '+' ? value1 + value2 : value1 - value2;\n\n  // Check if we have decimals\n  if (value1 % 1 !== 0 || value2 % 1 !== 0) {\n    const value1Decimal = value1.toString().split('.');\n    const value2Decimal = value2.toString().split('.');\n    const value1DecimalLength = (value1Decimal[1] && value1Decimal[1].length) || 0;\n    const value2DecimalLength = (value2Decimal[1] && value2Decimal[1].length) || 0;\n    const multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength));\n\n    // Transform the decimals to integers based on the precision\n    value1 = Math.round(value1 * multiplier);\n    value2 = Math.round(value2 * multiplier);\n\n    // Perform the operation on integers values to make sure we don't get a fancy decimal value\n    result = operator === '+' ? value1 + value2 : value1 - value2;\n\n    // Transform the integer result back to decimal\n    result /= multiplier;\n  }\n\n  return result;\n}\n"],"names":["useNumberFieldState","props","minValue","maxValue","step","formatOptions","value","defaultValue","onChange","locale","isDisabled","isReadOnly","numberValue","setNumberValue","useControlledState","isNaN","NaN","inputValue","setInputValue","useState","NumberFormatter","format","numberParser","useMemo","NumberParser","numberingSystem","getNumberingSystem","formatter","intlOptions","resolvedOptions","useCallback","clampStep","style","useEffect","parsedValue","parse","parsed","useRef","current","commit","length","undefined","clampedValue","clamp","snapValueToStep","safeNextStep","operation","minMax","prev","newValue","handleDecimalOperation","increment","previousValue","decrement","incrementToMax","decrementToMin","canIncrement","canDecrement","validate","isValidPartialNumber","operator","value1","value2","result","value1Decimal","toString","split","value2Decimal","value1DecimalLength","value2DecimalLength","multiplier","Math","pow","max","round"],"version":3,"file":"module.js.map"}